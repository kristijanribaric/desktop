diff --git a/browser/components/sessionstore/SessionStore.sys.mjs b/browser/components/sessionstore/SessionStore.sys.mjs
index 2a055f0c5f34f0a2667f659185120c07d38f4e41..c0ab92bfc89306e4e7d3a43097beb2dc5c9189be 100644
--- a/browser/components/sessionstore/SessionStore.sys.mjs
+++ b/browser/components/sessionstore/SessionStore.sys.mjs
@@ -127,6 +127,9 @@ const TAB_EVENTS = [
   "TabGroupCollapse",
   "TabGroupExpand",
   "TabSplitViewActivate",
+  "TabAddedToEssentials",
+  "TabRemovedFromEssentials",
+  "ZenWorkspaceDataChanged",
 ];
 
 const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
@@ -196,6 +199,7 @@ ChromeUtils.defineESModuleGetters(lazy, {
   TabStateCache: "resource:///modules/sessionstore/TabStateCache.sys.mjs",
   TabStateFlusher: "resource:///modules/sessionstore/TabStateFlusher.sys.mjs",
   setTimeout: "resource://gre/modules/Timer.sys.mjs",
+  ZenSessionStore: "resource:///modules/zen/ZenSessionManager.sys.mjs",
 });
 
 ChromeUtils.defineLazyGetter(lazy, "blankURI", () => {
@@ -1261,10 +1265,7 @@ var SessionStoreInternal = {
    */
   get willAutoRestore() {
     return (
-      !PrivateBrowsingUtils.permanentPrivateBrowsing &&
-      (Services.prefs.getBoolPref("browser.sessionstore.resume_session_once") ||
-        Services.prefs.getIntPref("browser.startup.page") ==
-          BROWSER_STARTUP_RESUME_SESSION)
+      true
     );
   },
 
@@ -1934,6 +1935,9 @@ var SessionStoreInternal = {
       case "TabPinned":
       case "TabUnpinned":
       case "SwapDocShells":
+      case "TabRemovedFromEssentials":
+      case "TabAddedToEssentials":
+      case "ZenWorkspaceDataChanged":
         this.saveStateDelayed(win);
         break;
       case "TabGroupCreate":
@@ -2044,6 +2048,10 @@ var SessionStoreInternal = {
       this._windows[aWindow.__SSi].isTaskbarTab = true;
     }
 
+    if (aWindow.document.documentElement.hasAttribute("zen-unsynced-window")) {
+      this._windows[aWindow.__SSi].isZenUnsynced = true;
+    }
+
     let tabbrowser = aWindow.gBrowser;
 
     // add tab change listeners to all already existing tabs
@@ -2131,6 +2139,7 @@ var SessionStoreInternal = {
           null,
           "sessionstore-one-or-no-tab-restored"
         );
+        lazy.ZenSessionStore.onNewEmptySession(aWindow);
         this._deferredAllWindowsRestored.resolve();
       }
       // this window was opened by _openWindowWithState
@@ -2175,7 +2184,6 @@ var SessionStoreInternal = {
       if (closedWindowState) {
         let newWindowState;
         if (
-          AppConstants.platform == "macosx" ||
           !lazy.SessionStartup.willRestore()
         ) {
           // We want to split the window up into pinned tabs and unpinned tabs.
@@ -2239,6 +2247,15 @@ var SessionStoreInternal = {
       });
       this._shouldRestoreLastSession = false;
     }
+    else if (!aInitialState && isRegularWindow) {
+      let windowPromises = [];
+      for (let window of this._browserWindows) {
+        windowPromises.push(lazy.TabStateFlusher.flushWindow(window));
+      }
+      Promise.all(windowPromises).finally(() => {
+        lazy.ZenSessionStore.restoreNewWindow(aWindow, this);
+      });
+    }
 
     if (this._restoreLastWindow && aWindow.toolbar.visible) {
       // always reset (if not a popup window)
@@ -2491,7 +2508,7 @@ var SessionStoreInternal = {
       // 2) Flush the window.
       // 3) When the flush is complete, revisit our decision to store the window
       //    in _closedWindows, and add/remove as necessary.
-      if (!winData.isPrivate && !winData.isTaskbarTab) {
+      if (!winData.isPrivate && !winData.isTaskbarTab && !winData.isZenUnsynced) {
         this.maybeSaveClosedWindow(winData, isLastWindow);
       }
 
@@ -2512,7 +2529,7 @@ var SessionStoreInternal = {
 
         // Save non-private windows if they have at
         // least one saveable tab or are the last window.
-        if (!winData.isPrivate && !winData.isTaskbarTab) {
+        if (!winData.isPrivate && !winData.isTaskbarTab && !winData.isZenUnsynced) {
           this.maybeSaveClosedWindow(winData, isLastWindow);
 
           if (!isLastWindow && winData.closedId > -1) {
@@ -2608,6 +2625,7 @@ var SessionStoreInternal = {
       let alreadyStored = winIndex != -1;
       // If sidebar command is truthy, i.e. sidebar is open, store sidebar settings
       let shouldStore = hasSaveableTabs || isLastWindow;
+      lazy.ZenSessionStore.maybeSaveClosedWindow(winData, isLastWindow);
 
       if (shouldStore && !alreadyStored) {
         let index = this._closedWindows.findIndex(win => {
@@ -3408,7 +3426,7 @@ var SessionStoreInternal = {
     if (!isPrivateWindow && tabState.isPrivate) {
       return;
     }
-    if (aTab == aWindow.FirefoxViewHandler.tab) {
+    if (aTab == aWindow.FirefoxViewHandler.tab || aTab.hasAttribute("zen-empty-tab")) {
       return;
     }
 
@@ -4129,6 +4147,12 @@ var SessionStoreInternal = {
         Math.min(tabState.index, tabState.entries.length)
       );
       tabState.pinned = false;
+      tabState.zenEssential = false;
+      tabState.zenSyncId = null;
+      tabState.zenIsGlance = false;
+      tabState.zenGlanceId = null;
+      tabState.zenHasStaticLabel = false;
+      tabState.zenWorkspace = aWindow.gZenWorkspaces.activeWorkspace;
 
       if (inBackground === false) {
         aWindow.gBrowser.selectedTab = newTab;
@@ -4565,6 +4589,7 @@ var SessionStoreInternal = {
       // Append the tab if we're opening into a different window,
       tabIndex: aSource == aTargetWindow ? pos : Infinity,
       pinned: state.pinned,
+      essential: state.zenEssential,
       userContextId: state.userContextId,
       skipLoad: true,
       preferredRemoteType,
@@ -5414,7 +5439,7 @@ var SessionStoreInternal = {
 
     for (let i = tabbrowser.pinnedTabCount; i < tabbrowser.tabs.length; i++) {
       let tab = tabbrowser.tabs[i];
-      if (homePages.includes(tab.linkedBrowser.currentURI.spec)) {
+      if (homePages.includes(tab.linkedBrowser.currentURI.spec) && !tab.hasAttribute("zen-empty-tab")) {
         removableTabs.push(tab);
       }
     }
@@ -5525,7 +5550,7 @@ var SessionStoreInternal = {
 
     // collect the data for all windows
     for (ix in this._windows) {
-      if (this._windows[ix]._restoring || this._windows[ix].isTaskbarTab) {
+      if (this._windows[ix]._restoring || this._windows[ix].isTaskbarTab && !this._windows[ix].isZenUnsynced) {
         // window data is still in _statesToRestore
         continue;
       }
@@ -5668,11 +5693,12 @@ var SessionStoreInternal = {
     }
 
     let tabbrowser = aWindow.gBrowser;
-    let tabs = tabbrowser.tabs;
+    let tabs = aWindow.gZenWorkspaces.allStoredTabs;
     /** @type {WindowStateData} */
     let winData = this._windows[aWindow.__SSi];
     let tabsData = (winData.tabs = []);
 
+    winData.splitViewData = aWindow.gZenViewSplitter?.storeDataForSessionStore();
     // update the internal state data for this window
     for (let tab of tabs) {
       if (tab == aWindow.FirefoxViewHandler.tab) {
@@ -5683,6 +5709,9 @@ var SessionStoreInternal = {
       tabsData.push(tabData);
     }
 
+    winData.folders = aWindow.gZenFolders?.storeDataForSessionStore() || [];
+    winData.activeZenSpace = aWindow.gZenWorkspaces?.activeWorkspace || null;
+    winData.spaces = aWindow.gZenWorkspaces?.getWorkspacesForSessionStore();
     // update tab group state for this window
     winData.groups = [];
     for (let tabGroup of aWindow.gBrowser.tabGroups) {
@@ -5695,7 +5724,7 @@ var SessionStoreInternal = {
     // a window is closed, point to the first item in the tab strip instead (it will never be the Firefox View tab,
     // since it's only inserted into the tab strip after it's selected).
     if (aWindow.FirefoxViewHandler.tab?.selected) {
-      selectedIndex = 1;
+      selectedIndex = 0;
       winData.title = tabbrowser.tabs[0].label;
     }
     winData.selected = selectedIndex;
@@ -5810,8 +5839,8 @@ var SessionStoreInternal = {
     // selectTab represents.
     let selectTab = 0;
     if (overwriteTabs) {
-      selectTab = parseInt(winData.selected || 1, 10);
-      selectTab = Math.max(selectTab, 1);
+      selectTab = parseInt(winData.selected || 0, 10);
+      selectTab = Math.max(selectTab, 0);
       selectTab = Math.min(selectTab, winData.tabs.length);
     }
 
@@ -5833,6 +5862,7 @@ var SessionStoreInternal = {
     if (overwriteTabs) {
       for (let i = tabbrowser.browsers.length - 1; i >= 0; i--) {
         if (!tabbrowser.tabs[i].selected) {
+          aWindow.gZenWorkspaces._shouldOverrideTabs = true;
           tabbrowser.removeTab(tabbrowser.tabs[i]);
         }
       }
@@ -5866,6 +5896,12 @@ var SessionStoreInternal = {
         savedTabGroup => !openTabGroupIdsInWindow.has(savedTabGroup.id)
       );
     }
+    if (winData.isZenUnsynced) {
+      aWindow.document.documentElement.setAttribute("zen-unsynced-window", "true");
+    }
+    aWindow.gZenFolders?.restoreDataFromSessionStore(winData.folders);
+    aWindow.gZenWorkspaces?.restoreWorkspacesFromSessionStore(winData);
+    aWindow.gZenViewSplitter?.restoreDataFromSessionStore(winData.splitViewData);
 
     // Move the originally open tabs to the end.
     if (initialTabs) {
@@ -6419,6 +6455,25 @@ var SessionStoreInternal = {
 
     // Most of tabData has been restored, now continue with restoring
     // attributes that may trigger external events.
+    if (tabData.zenEssential) {
+      tab.setAttribute("zen-essential", "true");
+      tabData.pinned = true; // Essential tabs are always pinned.
+    }
+    if (tabData.zenIsEmpty) {
+      tab.setAttribute("zen-empty-tab", "true");
+    }
+    if (typeof tabData.zenStaticLabel === "string") {
+      tab.zenStaticLabel = tabData.zenStaticLabel;
+    }
+    if (tabData.zenHasStaticIcon && tabData.image) {
+      tab.zenStaticIcon = tabData.image;
+    }
+    if (tabData.zenDefaultUserContextId) {
+      tab.setAttribute("zenDefaultUserContextId", true);
+    }
+    if (tabData.zenWorkspace) {
+      tab.setAttribute("zen-workspace-id", tabData.zenWorkspace);
+    }
 
     if (tabData.pinned) {
       tabbrowser.pinTab(tab);
@@ -7343,7 +7398,7 @@ var SessionStoreInternal = {
 
       let groupsToSave = new Map();
       for (let tIndex = 0; tIndex < window.tabs.length; ) {
-        if (window.tabs[tIndex].pinned) {
+        if (window.tabs[tIndex].pinned && false) {
           // Adjust window.selected
           if (tIndex + 1 < window.selected) {
             window.selected -= 1;
@@ -7358,7 +7413,7 @@ var SessionStoreInternal = {
           );
           // We don't want to increment tIndex here.
           continue;
-        } else if (window.tabs[tIndex].groupId) {
+        } else if (window.tabs[tIndex].groupId && false) {
           // Convert any open groups into saved groups.
           let groupStateToSave = window.groups.find(
             groupState => groupState.id == window.tabs[tIndex].groupId
