diff --git a/browser/components/tabbrowser/content/drag-and-drop.js b/browser/components/tabbrowser/content/drag-and-drop.js
index 97b931c3c7385a52d20204369fcf6d6999053687..bd64a97046d2a62e842cc922764ad129da99905f 100644
--- a/browser/components/tabbrowser/content/drag-and-drop.js
+++ b/browser/components/tabbrowser/content/drag-and-drop.js
@@ -32,6 +32,9 @@
    * @returns {MozTabbrowserTab|vbox}
    */
   const elementToMove = element => {
+    if (element.group?.hasAttribute("split-view-group")) {
+      return element.group;
+    }
     if (isTab(element)) {
       return element;
     }
@@ -112,6 +115,9 @@
       }
 
       let draggedTab = event.dataTransfer.mozGetDataAt(TAB_DROP_TYPE, 0);
+      if (draggedTab && dropEffect === "move") {
+        gZenViewSplitter.onBrowserDragEndToSplit(event);
+      }
       if (
         (dropEffect == "move" || dropEffect == "copy") &&
         document == draggedTab.ownerDocument &&
@@ -130,10 +136,6 @@
 
           // Pinned tabs in expanded vertical mode are on a grid format and require
           // different logic to drag and drop.
-          if (this._isContainerVerticalPinnedGrid(draggedTab)) {
-            this._animateExpandedPinnedTabMove(event);
-            return;
-          }
           this._animateTabMove(event);
           return;
         }
@@ -266,6 +268,15 @@
 
       this._tabDropIndicator.hidden = true;
       event.stopPropagation();
+      if (draggedTab && dropEffect == "move") {
+        this.handle_drop_transition?.(draggedTab._dragData.dropElement, draggedTab, movingTabs, draggedTab._dragData.dropBefore);
+        let moved = gZenPinnedTabManager.moveToAnotherTabContainerIfNecessary(event, movingTabs);
+
+        if (moved) {
+          this.finishMoveTogetherSelectedTabs(draggedTab);
+          return;
+        }
+      }
       if (draggedTab && dropEffect == "copy") {
         let duplicatedDraggedTab;
         let duplicatedTabs = [];
@@ -291,8 +302,9 @@
         let translateOffsetY = oldTranslateY % tabHeight;
         let newTranslateX = oldTranslateX - translateOffsetX;
         let newTranslateY = oldTranslateY - translateOffsetY;
-        let isPinned = draggedTab.pinned;
-        let numPinned = gBrowser.pinnedTabCount;
+        let isPinned = draggedTab?.group ? draggedTab.group.pinned : draggedTab.pinned;
+        let numPinned = gBrowser._numVisiblePinTabsWithoutCollapsed;
+        let essential = draggedTab.hasAttribute("zen-essential");
 
         if (this._isContainerVerticalPinnedGrid(draggedTab)) {
           // Update both translate axis for pinned vertical expanded tabs
@@ -308,8 +320,8 @@
           }
         } else {
           let tabs = this._tabbrowserTabs.ariaFocusableItems.slice(
-            isPinned ? 0 : numPinned,
-            isPinned ? numPinned : undefined
+            isPinned ? (essential ? 0 : gBrowser._numZenEssentials) : numPinned,
+            isPinned ? (essential ? gBrowser._numZenEssentials : numPinned) : undefined 
           );
           let size = this._tabbrowserTabs.verticalMode ? "height" : "width";
           let screenAxis = this._tabbrowserTabs.verticalMode
@@ -362,11 +374,13 @@
           this._dragToPinPromoCard,
         ];
         let shouldPin =
+          false &&  
           isTab(draggedTab) &&
           !draggedTab.pinned &&
           (overPinnedDropIndicator ||
             dragToPinTargets.some(el => el.contains(event.target)));
         let shouldUnpin =
+          false &&
           isTab(draggedTab) &&
           draggedTab.pinned &&
           this._tabbrowserTabs.arrowScrollbox.contains(event.target);
@@ -384,6 +398,7 @@
             (oldTranslateY && oldTranslateY != newTranslateY);
         } else if (this._tabbrowserTabs.verticalMode) {
           shouldTranslate &&= oldTranslateY && oldTranslateY != newTranslateY;
+          shouldTranslate = false;
         } else {
           shouldTranslate &&= oldTranslateX && oldTranslateX != newTranslateX;
         }
@@ -440,7 +455,7 @@
                 item.removeAttribute("tabdrop-samewindow");
                 resolve();
               };
-              if (gReduceMotion) {
+              if (true || gReduceMotion) {
                 postTransitionCleanup();
               } else {
                 let onTransitionEnd = transitionendEvent => {
@@ -581,6 +596,7 @@
 
           let nextItem = this._tabbrowserTabs.ariaFocusableItems[newIndex];
           let tabGroup = isTab(nextItem) && nextItem.group;
+          if (gZenViewSplitter.handleTabDrop(event, urls, replace, inBackground)) return;
           gBrowser.loadTabs(urls, {
             inBackground,
             replace,
@@ -618,7 +634,16 @@
         this._expandGroupOnDrop(draggedTab);
       }
       this._resetTabsAfterDrop(draggedTab.ownerDocument);
-
+      if (!dt.mozUserCancelled && dt.dropEffect == "none" && !this._isCustomizing) {
+        const moved = gZenViewSplitter.moveTabToSplitView(event, draggedTab);
+        if (moved) {
+          delete draggedTab._dragData;
+          return;
+        }
+      } else if (dt.mozUserCancelled) {
+        gZenViewSplitter.onBrowserDragEndToSplit(event, true);
+        if (gZenViewSplitter._lastOpenedTab) gZenViewSplitter._lastOpenedTab._visuallySelected = false;
+      }
       if (
         dt.mozUserCancelled ||
         dt.dropEffect != "none" ||
@@ -822,7 +847,10 @@
     _getDragTarget(event, { ignoreSides = false } = {}) {
       let { target } = event;
       while (target) {
-        if (isTab(target) || isTabGroupLabel(target)) {
+        if (isTab(target) || isTabGroupLabel(target) || target?.classList?.contains("tab-group-label-container")) {
+          if (target.classList?.contains("tab-group-label-container")) {
+            target = target.querySelector(".tab-group-label");
+          }
           break;
         }
         target = target.parentNode;
@@ -839,14 +867,17 @@
           return null;
         }
       }
+      if (target?.group?.hasAttribute("split-view-group")) {
+        target = target.group.labelElement;
+      }
       return target;
     }
 
     _isContainerVerticalPinnedGrid(tab) {
       return (
         this._tabbrowserTabs.verticalMode &&
-        tab.pinned &&
-        this._tabbrowserTabs.hasAttribute("expanded") &&
+        tab.hasAttribute("zen-essential") &&
+        (this._tabbrowserTabs.hasAttribute("expanded") || document.documentElement.hasAttribute("zen-sidebar-expanded")) &&
         !this._tabbrowserTabs.expandOnHover
       );
     }
@@ -877,7 +908,8 @@
         isTabGroupLabel(draggedTab) &&
         draggedTab._dragData?.expandGroupOnDrop
       ) {
-        draggedTab.group.collapsed = false;
+        draggedTab.group.collapsed = draggedTab.group.hasAttribute("has-active");
+        gZenFolders.animateGroupMove(draggedTab.group, true);
       }
     }
 
@@ -1055,7 +1087,6 @@
         // using updateDragImage. On Linux, we can use a panel.
         if (platform == "win" || platform == "macosx") {
           captureListener = function () {
-            dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);
           };
         } else {
           // Create a panel to use it in setDragImage
@@ -1093,7 +1124,6 @@
         );
         dragImageOffset = dragImageOffset * scale;
       }
-      dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);
 
       // _dragData.offsetX/Y give the coordinates that the mouse should be
       // positioned relative to the corner of the new window created upon
@@ -1112,7 +1142,7 @@
       let dropEffect = this.getDropEffectForTabDrag(event);
       let isMovingInTabStrip = !fromTabList && dropEffect == "move";
       let collapseTabGroupDuringDrag =
-        isMovingInTabStrip && isTabGroupLabel(tab) && !tab.group.collapsed;
+        isMovingInTabStrip && isTabGroupLabel(tab) && (!tab.group.collapsed || tab.group.hasAttribute("has-active"));
 
       tab._dragData = {
         offsetX: this._tabbrowserTabs.verticalMode
@@ -1122,7 +1152,7 @@
           ? event.screenY - window.screenY - tabOffset
           : event.screenY - window.screenY,
         scrollPos:
-          this._tabbrowserTabs.verticalMode && tab.pinned
+          this._tabbrowserTabs.verticalMode && tab.pinned && false
             ? this._tabbrowserTabs.pinnedTabsContainer.scrollPosition
             : this._tabbrowserTabs.arrowScrollbox.scrollPosition,
         screenX: event.screenX,
@@ -1149,6 +1179,7 @@
 
           if (collapseTabGroupDuringDrag) {
             tab.group.collapsed = true;
+            gZenFolders.animateGroupMove(tab.group);
           }
         }
       }
@@ -1173,6 +1204,7 @@
       if (tabStripItemElement.hasAttribute("dragtarget")) {
         return;
       }
+      return;
       let isPinned = tab.pinned;
       let numPinned = gBrowser.pinnedTabCount;
       let allTabs = this._tabbrowserTabs.ariaFocusableItems;
@@ -1598,7 +1630,6 @@
 
       for (let item of this._tabbrowserTabs.ariaFocusableItems) {
         item = elementToMove(item);
-        item.style.transform = "";
         item.removeAttribute("multiselected-move-together");
         delete item._moveTogetherSelectedTabsData;
       }
@@ -2426,7 +2457,6 @@
       for (let item of this._tabbrowserTabs.ariaFocusableItems) {
         this._resetGroupTarget(item);
         item = elementToMove(item);
-        item.style.transform = "";
       }
       this._tabbrowserTabs.removeAttribute("movingtab-group");
       this._tabbrowserTabs.removeAttribute("movingtab-ungroup");
@@ -2457,17 +2487,14 @@
         tab.style.left = "";
         tab.style.top = "";
         tab.style.maxWidth = "";
-        tab.removeAttribute("dragtarget");
       }
       for (let label of draggedTabDocument.getElementsByClassName(
         "tab-group-label-container"
       )) {
         label.style.width = "";
-        label.style.height = "";
         label.style.left = "";
         label.style.top = "";
         label.style.maxWidth = "";
-        label.removeAttribute("dragtarget");
       }
       let periphery = draggedTabDocument.getElementById(
         "tabbrowser-arrowscrollbox-periphery"
